import Users from "../models/users.js";
import jwt from "jsonwebtoken";
import bcrypt from "bcrypt";
import dotenv from "dotenv";
import { acessTokenExpiryDate, refreshTokenExpiryDate, resetTokenExpiryDate } from "../Config/Config.js";
dotenv.config();
import nodemailer from "nodemailer";

/*
A JWT consists of three parts:

Header: Contains metadata about the token, such as the algorithm used to sign it.
Payload: Contains the claims or data you want to transmit.
Signature: Ensures that the token has not been tampered with.
Decoding JWT
Decoding a JWT simply means Base64url-decoding the Header and Payload. This reveals the content of these parts but not the Signature or the key used to generate it. The Signature is a cryptographic hash of the Header and Payload, generated using a secret key (in HMAC algorithms) or a private key (in RSA or ECDSA algorithms).
Why You Can't Get the Secret Key
Hashing and Signing: The Signature in a JWT is created using a cryptographic algorithm. For HMAC algorithms, the Signature is a hash computed with a secret key, but the process is one-way. You cannot reverse the hash to find the original key.

One-Way Functions: Hashing functions (like those used in HMAC) are designed to be one-way operations. They produce a fixed-size hash from an input, but it is computationally infeasible to reverse the process to get the original input or secret key.

Key Protection: Secret keys are meant to be kept secure and not exposed. Even though you can decode the contents of a JWT, you cannot derive or extract the secret key from the JWT itself. */
const userssignup = async (req, res) => {
  
  try {
    // Check if the user email already exists
    let check = await Users.findOne({ email: req.body.email, authProvider: "jwt" });
    if (check) {
      return res.status(400).json({
        success: false,
        message: "User with this email already exists",
      });
    }

    // Hash the password before saving the user
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(req.body.password, salt);
    // auth cycle 1: first sends role user or admin while in signup goes to generateTokens
    // model created
    const user = new Users({
      name: req.body.name,
      email: req.body.email,
      password: hashedPassword,
      photo: req.body.photo,
      role: req.body.role,
      authProvider: "jwt"
    });

    await user.save();

    /*acessToken valid for minutes you set(not more than 15 min is good) after request sent from frontend and new refresh token is generated by const refreshToken. local/session and document.cookies storage not good in frontend*/
    /*in jwt token sign or creation takes two argument first what you want eg.here { id: user.id, role: user.role } and second process.env.ACCESS_TOKEN_SECRET. later during jwt.verify it verifies token with  same argument provided here.
    these argument are converted to tokens and in jwt.verify tokens converted to  { id: user.id, role: user.role },
      process.env.ACCESS_TOKEN_SECRET. if it matches verification complete. so imp to keep process.env.ACCESS_TOKEN_SECRET in env file whereas { id: user.id, role: user.role } will be different to different user so good. jwt always produces same token for same character. if you pass argument as below three tokens are created separated by(.).first one The JWT header is the first part of the token and contains metadata about the JWT itself, such as the type of token and the signing algorithm used. It is JSON-encoded and typically looks like this: second one for { id: user.id, role: user.role } one for process.env.ACCESS_TOKEN_SECRET(The signature is the final part of the JWT and is used to verify the integrity of the token. It is created by taking the encoded header, encoded payload and a secret key )*/
    // auth cycle 2: sends role user or admin data along with id and token goes to authMiddleware authenticateToken

    const accessToken = jwt.sign(
      { id: user.id, role: user.role },
      process.env.ACCESS_TOKEN_SECRET,
      { expiresIn: acessTokenExpiryDate }
    );

    /*refresh token set in cookie by http method is secured n these can't be accesed by javascript until you save them
    using local/session atorege.never do it. cookie are automatically send to backend in every request from frontend. that's why it is used to authenticate and
used by third party to store user activity, data e.t.c. storing capacity of cookies are less like in kb only.*/
    res.cookie("accessToken", accessToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production", // Use secure cookies in production
      sameSite: "strict", // Prevent CSRF attacks
    });

    /* The result of jwt.sign() is a string which is the generated JWT. This string contains three parts separated by dots (.): header, payload, and signature. For example:

Copy code
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
The first part (eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9) is the header, specifying the algorithm used and the token type.
The second part (eyJpZCI6MSwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ) is the payload, which contains the encoded data ({ id: user.id, role: user.role }) and any other information you included.
The third part (SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c) is the signature, which is used to verify that the token is valid and hasn't been tampered with. */
    const refreshToken = jwt.sign(
      { id: user.id, role: user.role },
      process.env.REFRESH_TOKEN_SECRET,
      { expiresIn: refreshTokenExpiryDate }
    );

    // Save the refresh token in the database
    user.refreshToken = refreshToken;
    await user.save();

    res.cookie("refreshToken", refreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "strict",
    });

    return res.status(201).json({
      success: true,
      accessToken,
      refreshToken,
      user: {
        name: user.name,
        email: user.email,
        role: user.role,
        photo: user.photo,
        _id: user._id,
        createdAt: user.createdAt,
        updatedAt: user.updatedAt,
        authProvider: user.authProvider
      },
    });
  } catch (error) {
    return res.status(500).json({ success: false, error });
  }
};

const userslogin = async (req, res) => {
  // auth cycle 1: after login user contains data about user including role
  try {
    const user = await Users.findOne({ email: req.body.email, authProvider: "jwt" });

    if (!user) {
      return res
        .status(400)
        .json({ success: false, message: "Wrong email or password" });
    }

    // Compare the plaintext password with the hashed password
    const comparePass = bcrypt.compare(req.body.password, user.password);
    if (!comparePass) {
      return res
        .status(400)
        .json({ success: false, message: "Wrong email or password" });
    }

    //Generate accessToken. contains user info role and id which determines role based auth
    // auth cycle 2: sends role user or admin data along with id and token goes to authMiddleware authenticateToken

    const accessToken = jwt.sign(
      { id: user.id, role: user.role },
      process.env.ACCESS_TOKEN_SECRET,
      { expiresIn: acessTokenExpiryDate }
    );

    res.cookie("accessToken", accessToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production", // Use secure cookies in production
      sameSite: "strict", // Prevent CSRF attacks
    });

    const refreshToken = jwt.sign(
      { id: user.id, role: user.role },
      process.env.REFRESH_TOKEN_SECRET,
      { expiresIn: refreshTokenExpiryDate }
    );

    // Save the refresh token in the database
    user.refreshToken = refreshToken;
    await user.save();

    // httpOnly: true ensures javascript(document.cookie/cookies-parser) cannot access token
    res.cookie("refreshToken", refreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "strict",
    });
    // Return response with new access token
    return res.json({
      success: true,
      accessToken,
      refreshToken,
      user: {
        name: user.name,
        email: user.email,
        role: user.role,
        _id: user._id,
        photo: user.photo,
        createdAt: user.createdAt,
        updatedAt: user.updatedAt,
        authProvider: user.authProvider
      },
    });
  } catch (error) {
    return res.status(500).json({ success: false, message: error.message });
  }
};

/*When an access token expires, the user would need to log in again unless a refresh token is used to obtain a new access token.The refreshToken function allows the user to get a new access token without requiring them to log in again, as long as the refresh token is still valid */
const refreshToken = async (req, res) => {
  /*to receive refreshToken from body const { refreshToken } = req.body; */
  /* acessing token through cookies not req.body coz it is secure.*/
  // when received through cookies in thunder client check it by headers(authorization bearer)
  const { refreshToken } = req.cookies;

  if (!refreshToken) {
    return res.status(401).json({ success: false, message: "unauthorized" });
  }

  const user = await Users.findOne({ refreshToken });

  if (!user) {
    return res
      .status(403)
      .json({ success: false, message: "insufficient permission" });
  }
  //  jwt.verify(token
  /*The jwt.verify function is used to decode and verify the JWT token (refreshToken).
It takes three parameters:
refreshToken: The JWT token that you want to decode and verify.
process.env.REFRESH_TOKEN_SECRET: This is the secret key (or public key in case of asymmetric algorithms) used to verify the JWT token's signature.
An asynchronous callback function (err, userData) which receives the decoded payload (userData) or an error (err) if verification fails. generally used decoded  instead of userData. it decodes token which we generated using user.id  etc and decoding decodes token and converts it and we can get data like id e.t.c*/
  jwt.verify(
    refreshToken,
    process.env.REFRESH_TOKEN_SECRET,
    async (err, userData) => {
      if (err)
        return res
          .status(403)
          .json({ success: false, message: "insufficient permission" });

      const newAccessToken = jwt.sign(
        { id: userData.id, role: userData.role },
        process.env.ACCESS_TOKEN_SECRET,
        { expiresIn: acessTokenExpiryDate }
      );

      // A new refresh token is issued every time the old one is used. The old refresh token is invalidated in the database.
      /* the payload { id: userData.id, role: userData.role } along with process.env.REFRESH_TOKEN_SECRET is used to sign new tokens. This payload is essential for maintaining the user's identity and authorization level when issuing new access and refresh tokens*/
      const newRefreshToken = jwt.sign(
        { id: userData.id, role: userData.role },
        process.env.REFRESH_TOKEN_SECRET,
        { expiresIn: refreshTokenExpiryDate }
      );

      // Update the refresh token in the database
      user.refreshToken = newRefreshToken;
      await user.save();

      res.cookie("accessToken", newAccessToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "strict",
      });

      res.cookie("refreshToken", newRefreshToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "strict",
      });

      res
        .status(201)
        .json({ accessToken: newAccessToken, refreshToken: newRefreshToken });
    }
  );
};

// Logout
const logout = async (req, res) => {
  const { refreshToken } = req.cookies;

  if (!refreshToken) {
    return res
      .status(400)
      .json({ success: false, message: "Refresh token not found" });
  }

  try {
    await Users.findOneAndUpdate({ refreshToken }, { refreshToken: null });
    res.clearCookie("accessToken");
    res.clearCookie("refreshToken");
    res.status(200).json({ success: true, message: "Successfully logged out" });
  } catch (error) {
    return res.status(500).json({ success: false, message: error.message });
  }
};

// Controller function to handle password reset requests
const requestPasswordReset = async (req, res) => {
  /* when user clicks reset button in frontend it handles it.checks email, generates token and sends to mail id of user  */ 
  try {
    const user = await Users.findOne({ email: req.body.email, authProvider: "jwt" });
    if (!user) {
      return res
        .status(400)
        .json({
          success: false,
          message: "User with this email does not exist",
        });
    }

    const resetToken = jwt.sign(
      { id: user._id },
      process.env.RESET_TOKEN_SECRET,
      { expiresIn: resetTokenExpiryDate }
    );

    
    // To send email from admin to user. Here, Gmail and nodemailer module are used
    // Purpose: This is used to authenticate with the email service (Gmail in this case). It tells Nodemailer which email account to use for sending emails.
    // Usage: This should be set to the email address that you own and have access to, from which you will send emails.
    const transporter = nodemailer.createTransport({
      service: "Gmail",
      auth: {
        // When using Gmail, it is highly recommended to use an App-Specific Password instead of your actual Gmail password. This enhances security and allows you to revoke access without changing your main Gmail password.
        user: process.env.EMAIL,
        pass: process.env.EMAIL_PASSWORD,
      },
    });

    // Sender and receiver of email containing resetUrl
    // This email address will appear in the user's inbox. Does not need to be a real address; can have process.env.EMAIL or other that matches your app. but google policy will only show process.env.EMAIL even mentioned <ecommerceclone@mail.com>. only shows "Ecommerce Clone"
    const mailOptions = {
      from:  '"Ecommerce Clone" <ecommerceclone@mail.com>', 
      to: user.email, // Recipient's email address
      subject: "Password Reset", // Email subject
      /* http://localhost:5173/reset-password is the URL that users will be directed when they click link inside their email. In deployment, need to change http://localhost:5173 */
      text: `http://localhost:5173/reset-password?token=${resetToken}&email=${req.body.email}`,
    };

    transporter.sendMail(mailOptions, (error, info) => {
      if (error) {
        return res
          .status(500)
          .json({ success: false, message: "Email could not be sent" });
      }
      res
        .status(200)
        .json({
          success: true,
          message: "Password reset email sent successfully. Check your email",
        });
    });
  } catch (error) {
    return res.status(500).json({ success: false, message: error.message });
  }
};

// Controller function to handle password reset
const resetPassword = async (req, res) => {
  /* after token is send from mail id of user frontend with token sends to this controller. this controller verifies token and updates password. process is complete.*/
  const { token, email, password } = req.body;

  // Verify the token
  jwt.verify(token, process.env.RESET_TOKEN_SECRET, async (err, decoded) => {
    if (err) {
      return res.status(403).json({ success: false, message: "Insufficient permission" });
    }

    try {
      // Find the user by email
      const user = await Users.findOne({ email: email, authProvider: "jwt" });
      if (!user) {
        return res.status(400).json({ success: false, message: "Invalid or expired token" });
      }

      // Generate a salt and hash the new password
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash(password, salt);

      // Update the user's password
      user.password = hashedPassword;
      await user.save();

      // Return a success response
      res.status(200).json({ success: true, message: "Password reset successfully" });
    } catch (error) {
      // Handle any errors that occur during the process
      console.error("Error resetting password:", error);
      return res.status(500).json({ success: false, message: error.message });
    }
  });
};
const jwtEmailConfirmation = async (req, res) => {
  

    const jwtEmailConfirmationToken = jwt.sign(
      { email: req.body.email },
      process.env.RESET_TOKEN_SECRET,
      { expiresIn: resetTokenExpiryDate }
    );

    
    // To send email from admin to user. Here, Gmail and nodemailer module are used
    // Purpose: This is used to authenticate with the email service (Gmail in this case). It tells Nodemailer which email account to use for sending emails.
    // Usage: This should be set to the email address that you own and have access to, from which you will send emails.
    const transporter = nodemailer.createTransport({
      service: "Gmail",
      auth: {
        // When using Gmail, it is highly recommended to use an App-Specific Password instead of your actual Gmail password. This enhances security and allows you to revoke access without changing your main Gmail password.
        user: process.env.EMAIL,
        pass: process.env.EMAIL_PASSWORD,
      },
    });

    // Sender and receiver of email containing resetUrl
    // This email address will appear in the user's inbox. Does not need to be a real address; can have process.env.EMAIL or other that matches your app. but google policy will only show process.env.EMAIL even mentioned <ecommerceclone@mail.com>. only shows "Ecommerce Clone"
    const mailOptions = {
      from:  '"Ecommerce Clone" <ecommerceclone@mail.com>', 
      to: req.body.email, // Recipient's email address
      subject: "email registration confirmation", // Email subject
      /* http://localhost:5173/reset-password is the URL that users will be directed when they click link inside their email. In deployment, need to change http://localhost:5173 */
      text: `http://localhost:5173/register?token=${jwtEmailConfirmationToken}&email=${req.body.email}`,
    };

    transporter.sendMail(mailOptions, (error, info) => {
      if (error) {
        return res
          .status(500)
          .json({ success: false, message: "Email could not be sent" });
      }
      res
        .status(200)
        .json({
          success: true,
          message: "email confirmation link sent successfully. Check your email",
        });
    });
  };

const getAllUsers = async(req, res) => {
  try {
    const data = await Users.find();
    res.status(200).json({ success: true, message: 'successfully fetched all users', data})
  } catch (error) {
    res.status(500).json({ success: false, message: 'error fetching users', error: error})
  }
};


const adminProfileEdit = async (req, res) => {
  
  const _id = req.body.adminId;
  if (!_id) {
    return res.status(400).json({ success: false, message: "Unauthorized Request" });
  }

  try {
    // Hash the password before updating if it is provided
    let updateData = { email: req.body.email,
                       photo: req.body.photo
                      };
    if (req.body.password) {
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash(req.body.password, salt);
      updateData.password = hashedPassword;
    }

    const data = await Users.findByIdAndUpdate(
      _id,
      updateData,
      { new: true }
    );

    if (!data) {
      return res.status(404).json({ success: false, message: "User not found" });
    } else {
      return res.status(200).json({ success: true, message: "Profile updated successfully", data });
    }
  } catch (err) {
    return res.status(500).json({ success: false, message: "Error updating profile", error: err.message });
  }
};

const userProfileEdit = async (req, res) => {
  
  const _id = req.body.userId;
  if (!_id) {
    return res.status(400).json({ success: false, message: "Unauthorized Request" });
  }

  try {
    // Hash the password before updating if it is provided
    let updateData = { email: req.body.email,
                       photo: req.body.photo
                      };
    if (req.body.password) {
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash(req.body.password, salt);
      updateData.password = hashedPassword;
    }

    const data = await Users.findByIdAndUpdate(
      _id,
      updateData,
      { new: true }
    );

    if (!data) {
      return res.status(404).json({ success: false, message: "User not found" });
    } else {
      return res.status(200).json({ success: true, message: "Profile updated successfully", data });
    }
  } catch (err) {
    return res.status(500).json({ success: false, message: "Error updating profile", error: err.message });
  }
};

export {
  userssignup,
  userslogin,
  refreshToken,
  logout,
  requestPasswordReset,
  resetPassword,
  jwtEmailConfirmation,
  getAllUsers,
  adminProfileEdit,
  userProfileEdit
};
